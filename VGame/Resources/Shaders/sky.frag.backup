#version 440 core

#define PI 3.14159265359

out vec4 color;

in vec3 vs_pos;
in vec3 vs_sunNorm;
in vec3 vs_starPos;
in vec2 vs_texCoods;
in vec4 vs_viewPos;

uniform sampler2D tint;
uniform sampler2D tint2;
uniform sampler2D sun;
uniform float starIntensity;
uniform float aspectRatio;
uniform float dayTime;
uniform vec2 resolution;
uniform vec3 playerPosition;


float hash(float n) { return fract((1.f + sin(n)) * 415.92653); }
float noise3D(vec3 vector) {
    float xhash = hash(round(400 * vector.x) * 37.f);
    float yhash = hash(round(400 * vector.y) * 57.f);
    float zhash = hash(round(400 * vector.z) * 67.f);
    return fract(xhash + yhash + zhash);
}


struct rayT {
	vec3 origin;
	vec3 direction;
};

struct sphereT {
	vec3 origin;
	float radius;
	int material;
};

const int NUM_SAMPLES		  = 16;
const int NUM_SAMPLES_LIGHT   = 8;
const float EARTH_RADIUS	  = 6360e3;
const float ATMOSPHERE_RADIUS = 6420e3;
const sphereT ATMOSPHERE = sphereT(
	vec3(0, 0, 0), ATMOSPHERE_RADIUS, 0
);

const float hR = 7994.0; // Rayleigh
const float hM = 1200.0; // Mie

const vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6); // Rayleigh 
const vec3 betaM = vec3(21e-6); // Mie

vec3 sunDir = vec3(0, 1, 0);
const float SUN_POWER = 20.f;

bool isectSphere(in rayT ray, in sphereT sphere, 
		inout float t0, inout float t1) {

	vec3 rc = sphere.origin - ray.origin;
	float radius2 = sphere.radius * sphere.radius;
	float tca = dot(rc, ray.direction);
	float d2 = dot(rc, rc) - tca * tca;
	if (d2 > radius2) return false;
	float thc = sqrt(radius2 - d2);
	t0 = tca - thc;
	t1 = tca + thc;

	return true;
}

float rayleightPhase(float mu) {
	return 3.f * (1.f + mu * mu) / (16.f * PI);
}

const float g = 0.76f;
float henyeyGreensteinPhase(float mu) {
	return (1.f - g * g) / ((4.f + PI) * pow(1.f + g * g - 2.f * g * mu, 1.5f));
}


mat3 rotateAroundY(float angleDegrees) {
	float angle = radians(angleDegrees);
	float _sin = sin(angle),
		  _cos = cos(angle);

	return mat3(1, 0,     0, 
				0, _cos, -_sin, 
				0, _sin,  _cos);
}

rayT getPirmaryRay(in vec3 camLocalPoint, 
		inout vec3 camOrigin, inout vec3 camLookAt) {

	vec3 fwd = normalize(camLookAt - camOrigin);
	vec3 up = vec3(0, 1, 0);
	vec3 right = cross(up, fwd);
	up = cross(fwd, right);

	rayT ray;
	ray.origin = camOrigin,
	ray.direction = normalize(fwd + up * camLocalPoint.y + right * camLocalPoint.x);
	return ray;
}


float approx_air_column_density_ratio_along_2d_ray_for_curved_world(
    float xStart, float xStop, float z2, float r, float H) {
    
	float a = 0.45,
		  b = 0.45;

    float x0 = sqrt(max(r * r -z2, 0.f));
    if (xStart < x0 && -x0 < xStop && z2 < r*r)
        return 1e20;
    
    float r1      = r + 6.f * H;
    float x1      = sqrt(max(r1 * r1 - z2, 0.f));
    float xb      = x0 + (x1 - x0) * b;
    float rb2     = xb * xb + z2;
    float rb      = sqrt(rb2);
    float d2hdx2  = z2 / sqrt(rb2 * rb2 * rb2);
    float dhdx    = xb / rb; 
    float hb      = rb - r;
    float dx0     = x0          - xb;
    float dx_stop = abs(xStop ) - xb;
    float dx_start= abs(xStart) - xb;
    float h0      = (0.5f * a * d2hdx2 * dx0      + dhdx) * dx0      + hb;
    float h_stop  = (0.5f * a * d2hdx2 * dx_stop  + dhdx) * dx_stop  + hb;
    float h_start = (0.5f * a * d2hdx2 * dx_start + dhdx) * dx_start + hb;

    float rho0  = exp(-h0 / H);
    float sigma = 
        sign(xStop ) * max(H / dhdx * (rho0 - exp(-xStop  / H)), 0.f) 
      - sign(xStart) * max(H / dhdx * (rho0 - exp(-xStart / H)), 0.f);

    return min(abs(sigma), 1e20);
}

float approx_air_column_density_ratio_along_3d_ray_for_curved_world(
    vec3  P, vec3  V, float x, float r, float H) {

    float xz = dot(-P, V);
    float z2 = dot( P, P) - xz * xz;
    return approx_air_column_density_ratio_along_2d_ray_for_curved_world(0.f - xz, x - xz, z2, r, H);
}

bool getSunLight(in rayT ray,
	inout float optical_depthR,	inout float optical_depthM) {

	float t0, t1;
	isectSphere(ray, ATMOSPHERE, t0, t1);
    
    optical_depthR = 
        approx_air_column_density_ratio_along_3d_ray_for_curved_world (
            ray.origin,    // position of viewer
            ray.direction, // direction of viewer (unit vector)
            t1, // distance from the viewer at which we stop the "raymarch"
            EARTH_RADIUS, // radius of the planet
            hR  // scale height of the planet's atmosphere
        );
    optical_depthM = 
        approx_air_column_density_ratio_along_3d_ray_for_curved_world (
            ray.origin,    // position of viewer
            ray.direction, // direction of viewer (unit vector)
            t1, // distance from the viewer at which we stop the "raymarch"
            EARTH_RADIUS, // radius of the planet
            hM  // scale height of the planet's atmosphere
        );

	return true;
}

vec3 getIncidentLight(in rayT ray) {
	float t0, t1;
	if(!isectSphere(ray, ATMOSPHERE, t0, t1))
		return vec3(0.f);

	float marchStep = t1 / float(NUM_SAMPLES);
	float mu = dot(ray.direction, sunDir);
	
	float phaseR = rayleightPhase(mu);
	float phaseM = henyeyGreensteinPhase(mu);

	float optical_depthR = 0.f;
	float optical_depthM = 0.f;

	vec3 sumR = vec3(0);
	vec3 sumM = vec3(0);
	float marchPos = 0.f;

	for(int i = 0; i < NUM_SAMPLES; i++) {
		vec3 s = ray.origin + ray.direction * (marchPos + 0.5 * marchStep);
		float height = length(s) - EARTH_RADIUS;

		float hr = exp(-height / hR) * marchStep;
		float hm = exp(-height / hM) * marchStep;
		optical_depthR += hr;
		optical_depthM += hm;

		rayT lightRay;
		lightRay.origin = s,
		lightRay.direction = sunDir;
		
		float optical_depth_lightR = 0.f;
		float optical_depth_lightM = 0.f;
		bool overground = getSunLight(
			lightRay,
			optical_depth_lightR,
			optical_depth_lightM);

		if (overground) {
			vec3 tau =
				betaR * (optical_depthR + optical_depth_lightR) +
				betaM * 1.1 * (optical_depthM + optical_depth_lightM);
			vec3 attenuation = exp(-tau);

			sumR += hr * attenuation;
			sumM += hm * attenuation;
		}

		marchPos += marchStep;
	}

	return(
		SUN_POWER *
		(sumR * phaseR * betaR +
		sumM * phaseM * betaM)
	);
}


//#define TEST
void main() {
	vec3 posNorm = normalize(vs_pos);
	float fov = tan(radians(90.0));
	//vec2 pointNormalizedDeviceCoordinates = vs_viewPos.xy / vs_viewPos.z;
	//vec3 pointCam = vec3((2.f * pointNormalizedDeviceCoordinates - 1.f) * aspectRatio * fov, -1.f);
	
	vec3 pointCam = vec3((2.f * 0.05 - posNorm.xy) * -aspectRatio, -1.f);	
	vec3 col = vec3(0);

	mat3 rotation = rotateAroundY(-abs(sin(dayTime)) * 90.f);
	sunDir *= rotation;

#ifdef TEST
	
	vec3 p = pointCam;
    float z2 = p.x * p.x + p.y * p.y;
    float phi = atan(p.y, p.x);
    float theta = acos(1.f - z2);
    vec3 dir = vec3(
        sin(theta) * cos(phi),
        cos(theta),
        sin(theta) * sin(phi));

    rayT ray;
    ray.origin = vec3(playerPosition.x, EARTH_RADIUS + 1.f, playerPosition.z),
    ray.direction = dir;

    if(dot(ray.direction, vec3(0, 1, 0)) > 0.f)
      col = getIncidentLight(ray);
    else
		col = vec3(0.333); //texture(tint2, vs_texCoods).rgb;

#else
	vec3 eye = vec3(playerPosition.x, EARTH_RADIUS - 5.f, playerPosition.z);
    vec3 lookAt = vec3(0, EARTH_RADIUS + 1.5, 0);
    rayT ray = getPirmaryRay(pointCam, eye, lookAt);

    if(dot(ray.direction, vec3(0, 1, 0)) > 0.f)
      col = getIncidentLight(ray);
    else
		col = vec3(0.333); //texture(tint2, vs_texCoods).rgb;
#endif

	color = vec4(col, 1.f);
	//vec3 posNorm = normalize(vs_pos);
	//float dist = dot(vs_sunNorm, posNorm);
	//color = (1 - starIntensity) * texture(tint, vs_texCoods);
	
	//vec3 colorDay = texture(tint, vec2((vs_sunNorm.y + 1.0) / 2.0, max(0.01, posNorm.y))).rgb;
	//vec3 colorNight = texture(tint2, vec2((vs_sunNorm.y + 1.0) / 2.0, max(0.01, posNorm.y))).rgb;
	//color = texture(tint, vs_texCoods); //vec4(mix(colorDay, colorNight, dist*0.5+0.5), 1.f);
	//
	//if(dayTime >= 8 && dayTime <= 18) { }
	//else {
	//	float threshold = 0.995;
	//	float star_intensity = noise3D(normalize(vs_starPos));
	//
	//	if (star_intensity >= threshold) {
	//		star_intensity = pow((star_intensity - threshold) / (1.f - threshold), 6.f) * (-vs_sunNorm.y + 0.1);
	//		color += vec4(vec3(star_intensity), 1.f);
	//	}
	//}
	//
	//float radius = length(posNorm - vs_sunNorm);
	//if(radius < 0.1) {
    //    float time = clamp(vs_sunNorm.y, 0.01, 1.f);
    //    radius /= 0.075;
    //    if(radius < 1.0 - 0.001) {
    //       vec4 sunColor = texture(sun, vec2(radius, time));
	//		color = mix(color, sunColor, sunColor.a);
	//	}	
    //}	

	//color += vec4(starColor, 1.f);
	//color = (1 - starIntensity) * texture(tint, vs_texCoods) + starIntensity * vec4(starColor, 1.f); 
}





